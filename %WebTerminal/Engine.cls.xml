<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="%WebTerminal.Engine">
<Description>
This class represents the core of web terminal.
All operations with opened WebSocket placed here.
CLASS USES GLOBAL ^|"%SYS"|%WebTerminal.AuthKey for client
authorization.</Description>
<Super>%CSP.WebSocket,%Library.Routine</Super>
<TimeCreated>63047,60359.445979</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// USER CONSTANTS START

]]></Content>
</UDLText>

<Parameter name="authorizationTimeout">
<Description>
How long to wait for authorization key when connection established</Description>
<Default>5</Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[
// USER CONSTANTS END

]]></Content>
</UDLText>

<Property name="SharedConnection">
<Description><![CDATA[
This property determines whether the communication between the client and WebSocket server should be over a dedicated Gateway
conection or over a pool of shared connections.  It may be set to one of the following:
<br><ul>
<li><b>SharedConnection=0</b> - The WebSocket server communicates with the client via a dedicated Gateway connection. In this mode of operation the hosting connection is effectively 'private' to the application session.</li>
<li><b>SharedConnection=1</b> - The WebSocket server communicates asynchronously with the client via a fixed number of shared Gateway connections.</li>
</ul>]]></Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="lastClientId">
<Description>
Last joined client id</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ConstServerActionExecute">
<Type>%Char</Type>
<InitialExpression>$c(1)</InitialExpression>
</Property>

<Property name="ConstServerActionExecuteSQL">
<Type>%Char</Type>
<InitialExpression>$c(2)</InitialExpression>
</Property>

<Property name="ConstServerActionGenerateAutocomplete">
<Type>%Char</Type>
<InitialExpression>$c(3)</InitialExpression>
</Property>

<Property name="ConstServerActionWatch">
<Type>%Char</Type>
<InitialExpression>$c(4)</InitialExpression>
</Property>

<Property name="ConstServerActionCheckWatches">
<Type>%Char</Type>
<InitialExpression>$c(5)</InitialExpression>
</Property>

<Property name="ConstServerActionReset">
<Type>%Char</Type>
<InitialExpression>$c(6)</InitialExpression>
</Property>

<Property name="ConstServerActionEcho">
<Type>%Char</Type>
<InitialExpression>$c(7)</InitialExpression>
</Property>

<Property name="ConstClientEnterClearIO">
<Type>%Char</Type>
<InitialExpression>$c(1)</InitialExpression>
</Property>

<Property name="ConstClientExitClearIO">
<Type>%Char</Type>
<InitialExpression>$c(2)</InitialExpression>
</Property>

<Property name="ConstClientOutputMessage">
<Type>%Char</Type>
<InitialExpression>$c(3)</InitialExpression>
</Property>

<Property name="ConstClientChangeNamespace">
<Type>%Char</Type>
<InitialExpression>$c(4)</InitialExpression>
</Property>

<Property name="ConstClientLoadAutocomplete">
<Type>%Char</Type>
<InitialExpression>$c(5)</InitialExpression>
</Property>

<Property name="ConstClientReadString">
<Type>%Char</Type>
<InitialExpression>$c(6)</InitialExpression>
</Property>

<Property name="ConstClientReadChar">
<Type>%Char</Type>
<InitialExpression>$c(7)</InitialExpression>
</Property>

<Property name="ConstClientAuthorizationStatus">
<Type>%Char</Type>
<InitialExpression>$c(8)</InitialExpression>
</Property>

<Property name="ConstClientWatch">
<Type>%Char</Type>
<InitialExpression>$c(9)</InitialExpression>
</Property>

<Property name="CurrentNamespace">
<Type>%String</Type>
</Property>

<Property name="InitialZName">
<Type>%String</Type>
</Property>

<Property name="Watches">
<Description>
Property is used to store watching files/globals. </Description>
<Type>%List</Type>
</Property>

<Property name="WatchesCaret">
<Description>
Watch position in file on global</Description>
<Type>%Numeric</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="redirects">
<Description>
Public point entries, using when redirecting i/o</Description>
<Internal>1</Internal>
<Private>1</Private>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
PrepareOutput(data)
	Try { Set data=$zconvert(data,"O","UTF8") } Catch {  }
	quit data
	
PrepareInput(data)
	Try { Set data=$zconvert(data,"I","UTF8") } Catch {  }
	quit data
	
//////////////////////////////////////////////
	
wstr(s)
	do ##class(%Device).ReDirectIO($$$NO) 
	w $$PrepareOutput(s),*-3
	do ##class(%Device).ReDirectIO($$$YES)
	quit 
wchr(c) 
	do ##class(%Device).ReDirectIO($$$NO) 
	w $$PrepareOutput($c(c)),*-3
	do ##class(%Device).ReDirectIO($$$YES) 
	quit
wnl 
	do ##class(%Device).ReDirectIO($$$NO) 
	w $c(13,10),*-3
	do ##class(%Device).ReDirectIO($$$YES)
	quit 
wff 
	do ##class(%Device).ReDirectIO($$$NO) 
	w $c(12),*-3
	do ##class(%Device).ReDirectIO($$$YES)
	quit 
wtab(s)
	do ##class(%Device).ReDirectIO($$$NO) 
	w $$PrepareOutput($j("",s-$x)),*-3
	do ##class(%Device).ReDirectIO($$$YES) 
	quit
	
rstr(len = 32656,timeout = 86400)
	do ##class(%Device).ReDirectIO($$$NO)
	w $c(6),*-3 // ..ConstClientReadString
	
	use $io:(::"+T")
	read data#5:timeout // package header
	read data:timeout
	use $io:(::"-T")
	
	set data = $$PrepareInput($EXTRACT(data,1,len))
	do ##class(%Device).ReDirectIO($$$YES)
	quit data
rchr(timeout = 86400)
	do ##class(%Device).ReDirectIO($$$NO)
	w $c(7),*-3 // ..ConstClientReadChar
	
	use $io:(::"+T")
	read data#5:timeout // package header
	read data:timeout
	use $io:(::"-T")
	
	set data = $$PrepareInput($ASCII($EXTRACT(data,1,1)))
	do ##class(%Device).ReDirectIO($$$YES)
	quit data
]]></Implementation>
</Method>

<Method name="OnPreServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="AddWatch">
<Description>
Chechs for correct watch source and sets watch target to ..Watches
Returns status of this operation</Description>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set s = $CHAR(0)
	set watches = s _ $LISTTOSTRING(..Watches, s) _ s
	if ($FIND(watches, s_name_s) '= 0) q 0 // if watch already defined
	
	if ($EXTRACT(name,1,1) = "^") { // watching global
		s g = 0
		try {
			if (($data(@name))'=0) s g = 1
		} catch {  }
		set $ZERROR = ""
		if (g = 1) {
			set ..Watches = ..Watches _ $LISTBUILD(name)
			set ..WatchesCaret(name,0) = $QUERY(@name@(""),-1) // last
			set ..WatchesCaret(name,1) = "?"
			do ..SendData(name, ..ConstClientWatch)
			q 1
		}
	} else { // watch file
		if (##class(%File).Exists(name)) {
			set ..Watches = ..Watches _ $LISTBUILD(name)
			set file = ##class(%File).%New(name)
			set ..WatchesCaret(name,0) = file.Size // current watch cursor position
			set ..WatchesCaret(name,1) = file.DateModified
			do ..SendData(name, ..ConstClientWatch)
			q 1
		}
	}
	
	q 0 // what do you want?
]]></Implementation>
</Method>

<Method name="RemoveWatch">
<Description>
Removes watch from watches list
Returns success status</Description>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// absurdly, but working
	set s = $CHAR(0)
	set watches = s _ $LISTTOSTRING(..Watches,s) _ s
	set newWatches = $REPLACE(watches, s_name_s, s)
	set ..Watches = $LISTFROMSTRING($EXTRACT(newWatches, 2, *-1), s)
	if (watches '= newWatches) {
		k ..WatchesCaret(name) // really removed
		do ..SendData(name, ..ConstClientWatch)
	}
	quit watches '= newWatches
]]></Implementation>
</Method>

<Method name="ListWatches">
<Description>
Returns a list current watches</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set no=0
	set s = "Watching: " _ $CHAR(10)
    while $LISTNEXT(..Watches, no, value) {
    	set s = s_"(pos: "_..WatchesCaret(value,0)_
    	"; mod: "_..WatchesCaret(value,1)_") "_value_$CHAR(10)
    }
    q s
]]></Implementation>
</Method>

<Method name="GetWatchGlobalModified">
<Description>
Return null string if global hadn't been updated
This method watches only for tail of global and detects if global still alive</Description>
<FormalSpec>watch</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set data = ""
	if ($data(@watch)=0) {
		do ..RemoveWatch(watch)
		q "removed"
	}
	for {
    	set query = $QUERY(@..WatchesCaret(watch,0))
        quit:query=""
        if (data="") set data = "modified"
        set ..WatchesCaret(watch,0) = query
        set data = data _ $CHAR(10) _ @query
  	}
  	q data
]]></Implementation>
</Method>

<Method name="GetWatchFileModified">
<FormalSpec>watch</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set file=##class(%File).%New(watch)
	set size = file.Size
	set modDate = file.DateModified
	set output = ""
	if (size < 0) { // file had been deleted
		 
		do ..RemoveWatch(watch)
		q "removed"
		
	}
	if (size > ..WatchesCaret(watch, 0)) {
		
		set output = "updated" _ $CHAR(10)
		set stream=##class(%Stream.FileBinary).%New()
		set sc=stream.LinkToFile(watch)
		do stream.MoveTo(..WatchesCaret(watch, 0) + 1)
		set readed = stream.Read(size - ..WatchesCaret(watch, 0))
		set output=output_readed
		set ..WatchesCaret(watch, 0) = size
		set ..WatchesCaret(watch, 1) = file.DateModified
		
	} elseif ((size < ..WatchesCaret(watch, 0)) || (file.DateModified '= ..WatchesCaret(watch, 1))) {
		
		set output = "modified" _ $CHAR(10)
		set output = output _ "Bytes changed: " _ (size - ..WatchesCaret(watch, 0))
		set ..WatchesCaret(watch, 0) = size
		set ..WatchesCaret(watch, 1) = file.DateModified
		
	} // else file not changed
	q output
]]></Implementation>
</Method>

<Method name="CheckWatches">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set no = 0
	set data = ""
	set overal = ""
	set watchList = ..Watches // do not remove or simplify: ..Watches can be modified
    while $LISTNEXT(watchList, no, value) {
    	if ($EXTRACT(value, 1, 1) = "^") {
  			set data = ..GetWatchGlobalModified(value)
    	} else {
	    	set data = ..GetWatchFileModified(value)
    	}
    	if (data '= "") {
	    	set overal = $ZDATETIME($NOW(),1,1) _ " " _
	    	value _ ": " _ data _ $CHAR(10)	
    	}
    	set data = ""
    }
    q overal
]]></Implementation>
</Method>

<Method name="OnPostServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^CacheTemp.WebTerminal.Watching
 	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetJSAutocompleteFilePath">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	set data = ##class(%Library.File).ManagerDirectory()
	set data = ##class(%Library.File).ParentDirectoryName(data)
	set data = data _ "CSP\sys\webTerminal\js\autocomplete\" _
		$REPLACE(namespace,"%","_") _ ".js" // UNIX?
	quit data
]]></Implementation>
</Method>

<Method name="WriteToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,data:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set file=##class(%File).%New(filename)
	do file.Open("WSN")
	do file.WriteLine(data)
	do file.Close()
]]></Implementation>
</Method>

<Method name="getGlobalsJSON">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

	set out = "{"
 	set rset=##class(%ResultSet).%New("%SYS.GlobalQuery:NameSpaceList")
 	set sc=rset.Execute($ZNSPACE,"*",0)
  	while (rset.Next()) {
		set out = out _ """" _ $Piece(rset.GetData(1),"(",1) _ """:0,"
  	}
  	set out = $EXTRACT(out,1,$LENGTH(out)-1) _ "}"
	q out
]]></Implementation>
</Method>

<Method name="GenerateAutocompleteFile">
<Description>
Generates autocomplete file for namespace. Second parameter deсides if
it will be regenerated again. But if namespace equals to "%" - generates
autocomplete file for system classes. Make sure that autocomplete for
system classes generates one time and forever. </Description>
<FormalSpec>namespace:%String,newFile:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	set filename = ..GetJSAutocompleteFilePath($NAMESPACE)
	
	set system = 0
	if (namespace = "%") {
		set namespace = "%SYS"
		set filename = ..GetJSAutocompleteFilePath("_")
		set system = 1
	}
	
	if (system) && (##class(%File).Exists(filename)) {
		do ..SendData("_", ..ConstClientLoadAutocomplete)
		quit $$$OK
	}
	
	do ..StartClearIO()
	
	if ('##class(%SYS.Namespace).Exists(namespace)) {
		do ..EndClearIO()
		do ..SendData("Wrong namespace: " _ namespace)
		quit $$$NOTOK
	}
	
	set namespace = $REPLACE(namespace,"%","_")
	
	if (##class(%File).Exists(filename)) && (newFile = 0) {
		
		do ..EndClearIO()
		do ..SendData(namespace, ..ConstClientLoadAutocomplete)
		quit $$$OK
		
	} elseif ('##class(%File).DirectoryExists(##class(%File).GetDirectory(filename))) {
		
		// try to create missed directory
		set result = ##class(%File).CreateDirectoryChain(##class(%File).GetDirectory(filename))
		
		if (result '= 1) {
			do ..EndClearIO()
			do ..SendData("Autocomplete fail: can't create directory js/autocomplete.")
			quit $$$OK
		}
		
	}

	set thisName = $REPLACE(namespace,"_","%")
	if (system) { set thisName = "SYSTEM" }
	do ..SendData("Generating language file for " _ thisName _ ", pleace, wait. ")
		
	// get all classes names
	set result = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:Summary")
	do result.Execute()
	
	/*	
	The next COULD BE IMPROVED FOR SPEED, I beleive.
	Generates compressed JSON string of type:
	{
		"class": {
			"%ClassName1": {
				"methodName": 0,
				"propertyName": 0,
				"parameterName": 0,
				...
			},
			"ClassName2": {
				...
			}
		},
		"global": {
			"^%g1": 0,
			"^g2": 0
		}
	}
	*/
	
	set file=##class(%File).%New(filename)
	do file.Open("WSN")
	
	// final data generation
	do file.Write("{""class"":{")
	set first = ""
	
	while (result.Next()) { // forming autocomplete for each class
	
		set className = result.Data("Name")
		if (($EXTRACT(className,1)="%")'=system) {
			continue
		}
		do file.Write(first _ """" _ className _ """:{")
		if (first = "") set first = ","
		
		set cdefs = ##class(%Dictionary.ClassDefinition).%OpenId(className)
 		
 		set countMethods = cdefs.Methods.Count()
 		set countParameters = cdefs.Parameters.Count()
 		set countProperties = cdefs.Properties.Count()
 		set total = countMethods + countParameters + countProperties
 		set current = 0
 		
 		for i=1:1:countMethods {
	 		set current = current + 1
     		do file.Write("""" _ cdefs.Methods.GetAt(i).Name _ """:0")
     		if (current'=total) do file.Write(",")
 		}
 		
 		for i=1:1:countProperties {
	 		set current = current + 1
     		do file.Write("""" _ cdefs.Properties.GetAt(i).Name _ """:0")
     		if (current'=total) do file.Write(",")
 		}
 		
 		for i=1:1:countParameters {
	 		set current = current + 1
     		do file.Write("""" _ cdefs.Parameters.GetAt(i).Name _ """:0")
     		if (current'=total) do file.Write(",")
 		}
		
		do file.Write("}")
		
	}
	
	do file.Write("}")
	if ('system) {
		do file.Write(",""global"":" _ ..getGlobalsJSON())	
	}
	do file.Write("}")
	do file.Close()
	
	do ..SendData($c(10)_"Language file for " _ thisName _ " generated.")
	
	do ..EndClearIO()
	if (system) {
		do ..SendData("_",..ConstClientLoadAutocomplete)
	} else { do ..SendData(namespace,..ConstClientLoadAutocomplete) }
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateAuthKey">
<Description>
Generating new authorization key</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	set ^|"%SYS"|%WebTerminal.AuthKey = $SYSTEM.Util.CreateGUID()
]]></Implementation>
</Method>

<Method name="GetAuthKey">
<Description>
Returns key for client authorization.
If the key is empty, generates new key value.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($get(^|"%SYS"|%WebTerminal.AuthKey) = "") {
		Do ..GenerateAuthKey()
	}
	quit ^|"%SYS"|%WebTerminal.AuthKey
]]></Implementation>
</Method>

<Method name="Reset">
<Description>
Backs terminal to default state</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// delete autocompletion files
	set dir = ##class(%File).GetDirectory(..GetJSAutocompleteFilePath("TEST"))
	if (##class(%File).DirectoryExists(dir)) {
		do ##class(%File).RemoveDirectoryTree(dir)
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="SendData">
<Description>
Function sends data derectly to server with specified action</Description>
<FormalSpec>query:%String="",action:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (action = "") { set action = ..ConstClientOutputMessage }
	do ..Write(action _ query) // using CTWPv3
]]></Implementation>
</Method>

<Method name="ExecuteSQL">
<FormalSpec>query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  	do ..StartClearIO()
 	do ##class(%Device).ReDirectIO($$$YES)
	
  	set tStatement = ##class(%SQL.Statement).%New()
  	set qStatus = tStatement.%Prepare(query)
  	if qStatus'=1 {
	  	write "SQL prepare error: ",$System.Status.DisplayError(qStatus)
	} else {
		set rset = tStatement.%Execute()
  		do rset.%Display()
	}
	
	do ##class(%Device).ReDirectIO($$$NO)
	do ..EndClearIO()
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="ClientAlertNamespace">
<Description>
Sends to client new namespace if last was changed</Description>
<Implementation><![CDATA[
	if (..CurrentNamespace '= $Znspace) { // change client namespace
	    set ..CurrentNamespace = $Znspace
	 	do ..SendData(..CurrentNamespace,..ConstClientChangeNamespace) 
    }
]]></Implementation>
</Method>

<Method name="StartClearIO">
<Description>
Starts clear I/O mode</Description>
<Implementation><![CDATA[
	write *-3
	do ##class(%Device).ReDirectIO($$$YES)
	do ..Write(..ConstClientEnterClearIO)
	write *-3
]]></Implementation>
</Method>

<Method name="EndClearIO">
<Description>
Ends clear I/O mode</Description>
<Implementation><![CDATA[
	write *-3
	do ##class(%Device).ReDirectIO($$$NO)
	do ..SendData("exit",..ConstClientExitClearIO)
	write *-3
]]></Implementation>
</Method>

<Method name="ParseError">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set string = $REPLACE($REPLACE(string, ">", "<"), ".Engine.", "<")
	quit "An error occured: " _ $PIECE(string, "<", 2) _
		$EXTRACT($PIECE(string, "<", 4), 2, *)
]]></Implementation>
</Method>

<Method name="ExecuteCommand">
<Description>
The heart of terminal application</Description>
<FormalSpec>query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (query = "") quit $$$OK
	
	#dim exception as %Exception.AbstractException
	set value = $Replace(query,$CHAR(10)," ")
	
	do ..StartClearIO() // execute session start
	
	set $ZERROR = ""
  	
    try { xecute value } catch exception {
	   	set $ZERROR = exception.DisplayString()
	}
	
   	if ($ZERROR '= "") {
		do ..SendData(..ParseError($ZERROR))
   	}
   	
   	do ..EndClearIO() // execute session end
	do ..ClientAlertNamespace() // check namespace change
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="RequireAuthorization">
<Description>
This method holds process and expects only one package from
the client - it includes authorization key.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set key = ..Read(,.status,..#authorizationTimeout) // wait for package
	set realKey = ..GetAuthKey() // remember current auth key
	do ..GenerateAuthKey() // generate new auth key
	
	if (key = realKey) {
		quit $$$OK
	}
	
	quit $$$NOTOK
]]></Implementation>
</Method>

<Method name="ClientLoop">
<Description><![CDATA[
Main method for every new client.

Authorization process description:
	1.	Client requests cache server page called "WebTerminal.csp";
	2.	Server return this page with ClassMethod GetAuthKey() value;
	3.	After client receives page, it performs websocket connection;
		to same web-resource, but with next URL changes:
		"http://" -> "ws://", "WebTerminal.csp" -> "Webterminal.Engine.cls";
	4.	After connection established, client sends his AuthKey to server
		and removes it locally (because it needed only one time);
	5.	Server compares again received key with ..GetAuthKey() value and
		grants permission, if keys are equal.
	>>	As a result - there is no way to autorize via websocket without
		accessing WebTerminal.csp.

Method description:
	First, method requires from client 
	a key, which will be compared with ..GetAuthKey() (global). If 
	succeeded, method sets "authorized" flag to true and changes global
	key with ..GenerateAuthKey() for the next client.]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	kill // clear junk vars
	
	for {
		
		set data = ..Read(,.status)
    
    	if $$$ISERR(status) {
	   
	    	try {
		    	do ..SendData("Error occured while reading data.",
	    		..ConstClientOutputMessage)
	    	} catch e { }
      		quit:($$$GETERRORCODE(status)=$$$CSPWebSocketClosed)
	    	
	   	}
	   	
	   	set action = $EXTRACT(data, 1, 1)
	   	set data = $EXTRACT(data, 2, *)
	   	
	   	if ($EXTRACT(data, *) = $c(10)) { // terminator
		 	set data = $EXTRACT(data, 1, *-1)
	   	}
	   	   	
	    if (action = ..ConstServerActionExecute) { // autorized
	    	
			do ..ExecuteCommand(data)
		    	
	    } elseif (action = ..ConstServerActionCheckWatches) {
	    
		    set changes = ..CheckWatches()
		    if (changes '= "") {
				do ..SendData(changes)   
		    }
		  
	    } elseif (action = ..ConstServerActionWatch) { // add/remove
	    
		    set result = ..AddWatch(data)
		    if ('$$$ISOK(result)) {
				set result = ..RemoveWatch(data)
				if ('$$$ISOK(result)) {
					do ..SendData("!" _ data, ..ConstClientWatch)
				}
		    }
		  
	    } elseif (action = ..ConstServerActionExecuteSQL) { // sql
	    
		    do ..ExecuteSQL(data)
		  
	    } elseif (action = ..ConstServerActionGenerateAutocomplete) {
		    
		    do ..GenerateAutocompleteFile("%", data)
		    do ..GenerateAutocompleteFile(..CurrentNamespace, data)
		    		
	    } elseif (action = ..ConstServerActionReset) {
		      
		    if ($$$ISOK(..Reset())) {
			    do ..SendData("Terminal state reseted.")
		    } else {
			    do ..SendData("Error while reseting terminal state.")
		    }
		    		
	    } elseif (action = ..ConstServerActionEcho) {
		      
		    do ..StartClearIO()
		    write data
		    do ..EndClearIO()
		    		
	    } else { // something scary
		    	
		    do ..SendData("Client request unrecognised: " _ action)
		    		
	    }
      		
	}
]]></Implementation>
</Method>

<Method name="Server">
<Description>
New connection established</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if ($$$ISOK(..RequireAuthorization())) {
		
		set ..InitialZName = $Zname
		set ..CurrentNamespace = $Znspace
		
		do ..SendData("1", ..ConstClientAuthorizationStatus)
		do ..SendData(..CurrentNamespace, ..ConstClientChangeNamespace)
		   
		use $io::("^" _ ..InitialZName)
		do ..ClientLoop()
		
	} else {
		
		do ..SendData("0", ..ConstClientAuthorizationStatus)
		do ..EndServer()
			
	}
  	
  	quit $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
